{
  "sha": "17582c44d4741a58cfe6385db37c5920768a6d3e",
  "url": "https://github.com/MicrosoftDocs/entra-docs/commit/17582c44d4741a58cfe6385db37c5920768a6d3e",
  "author": "learn-build-service-prod[bot]",
  "email": "113403604+learn-build-service-prod[bot]@users.noreply.github.com",
  "date": "2025-09-09T22:11:38Z",
  "message": "Merge pull request #9654 from MicrosoftDocs/main\n\nAuto Publish â€“ main to live - 2025-09-09 22:06 UTC",
  "ai_summary": {
    "Messages": "{\"role\":\"user\",\"content\":\"The following is the commit files that have changed: [\\r\\n  {\\r\\n    \\\"sha\\\": \\\"4f55a21c3b8636f6098d1a3d14f0d9c808fa148c\\\",\\r\\n    \\\"filename\\\": \\\"docs/global-secure-access/scripts/powershell-active-directory-certificate-service.md\\\",\\r\\n    \\\"status\\\": \\\"added\\\",\\r\\n    \\\"additions\\\": 168,\\r\\n    \\\"deletions\\\": 0,\\r\\n    \\\"changes\\\": 168,\\r\\n    \\\"blob_url\\\": \\\"https://github.com/MicrosoftDocs/entra-docs/blob/17582c44d4741a58cfe6385db37c5920768a6d3e/docs%2Fglobal-secure-access%2Fscripts%2Fpowershell-active-directory-certificate-service.md\\\",\\r\\n    \\\"raw_url\\\": \\\"https://github.com/MicrosoftDocs/entra-docs/raw/17582c44d4741a58cfe6385db37c5920768a6d3e/docs%2Fglobal-secure-access%2Fscripts%2Fpowershell-active-directory-certificate-service.md\\\",\\r\\n    \\\"contents_url\\\": \\\"https://api.github.com/repos/MicrosoftDocs/entra-docs/contents/docs%2Fglobal-secure-access%2Fscripts%2Fpowershell-active-directory-certificate-service.md?ref=17582c44d4741a58cfe6385db37c5920768a6d3e\\\",\\r\\n    \\\"patch\\\": \\\"@@ -0,0 +1,168 @@\\\\n+---\\\\n+title: PowerShell Sample - Create a TLS Certificate Using Active Directory Certificate Services\\\\n+description: Use this PowerShell script to create a TLS certificate using Active Directory Certificate Services (ADCS) in a test environment.\\\\n+author: HULKsmashGithub\\\\n+ms.author: jayrusso\\\\n+manager: dougeby\\\\n+ms.service: global-secure-access\\\\n+ms.topic: sample\\\\n+ms.date: 09/09/2025\\\\n+ms.reviewer: teresayao\\\\n+\\\\n+#customer intent: As an admin, I want to automate the creation of TLS certificates using PowerShell so that I can streamline my testing process.\\\\n+\\\\n+---\\\\n+\\\\n+# Use PowerShell to generate and sign TLS certificates using Active Directory Certificate Services\\\\n+\\\\n+This script automates generating and signing Transport Layer Security (TLS) certificates using Active Directory Certificate Services (ADCS). It creates a certificate signing request (CSR) using the TLS inspection graph API. The script then submits the certificate to ADCS for signing, retrieves the signed certificate, and uploads the certificate and chain to TLS inspection settings.\\\\n+\\\\n+## Generate and sign TLS certificates\\\\n+\\\\n+```powershell\\\\n+# This script requires the following:\\\\n+#    - PowerShell 5.1 (x64) or later\\\\n+#    - Module: Microsoft.Graph.Beta\\\\n+#\\\\n+# Before you begin:\\\\n+#    \\\\n+# - Make sure you're running PowerShell as an administrator\\\\n+# - Make sure you run: Install-Module Microsoft.Graph.Beta -AllowClobber -Force\\\\n+# - Make sure you have ADCS configured with a SubCA template and you have \\\\\\\"<CAHostName>\\\\\\\\<CACommonName>\\\\\\\"\\\\n+# Ensure Microsoft.Graph.Beta module is available\\\\n+\\\\n+# Import module\\\\n+\\\\n+Import-Module Microsoft.Graph.Beta.NetworkAccess\\\\n+\\\\n+# Connect to Microsoft Graph (handles token for you)\\\\n+Connect-MgGraph -Scopes \\\\\\\"NetworkAccess.ReadWrite.All\\\\\\\" -NoWelcome\\\\n+\\\\n+# Modify the following with your own settings before running the script:\\\\n+# Name of the certificate (letters and numbers only and within 12 characters)\\\\n+$name = \\\\\\\"TLSiCAName\\\\\\\"\\\\n+# Common Name (CN) for the certificate\\\\n+$commonName = \\\\\\\"Contoso TLS Demo\\\\\\\"\\\\n+# Organization Name (O) for the certificate\\\\n+$organizationName = \\\\\\\"Contoso\\\\\\\"\\\\n+#ADCS settings\\\\n+# Make sure you have ADCS configured with a SubCA template and you have \\\\\\\"<CAHostName>\\\\\\\\<CACommonName>\\\\\\\"\\\\n+$Template = \\\\\\\"SubCA\\\\\\\"\\\\n+$CAConfig=\\\\\\\"<CACommonName> of your ADCS server\\\\\\\"\\\\n+\\\\n+# Check if the External Certificate Authority Certificates already exists\\\\n+try {\\\\n+    $response = Get-MgBetaNetworkAccessTlExternalCertificateAuthorityCertificate\\\\n+    if ($response.Count -gt 0) \\\\n+    {\\\\n+     Write-Host \\\\\\\"A certificate for TLS inspection already exists.\\\\\\\"\\\\n+\\\\t exit 1\\\\n+    } \\\\n+}\\\\n+catch {\\\\n+    Write-Error \\\\\\\"Graph SDK call to check on the list of certificates failed: $($_.Exception.Message)\\\\\\\"\\\\n+}\\\\n+\\\\n+# Create the certificate signing request (CSR)\\\\n+\\\\n+$paramscsr = @{\\\\n+\\\\t\\\\\\\"@odata.type\\\\\\\" = \\\\\\\"#microsoft.graph.networkaccess.externalCertificateAuthorityCertificate\\\\\\\"\\\\n+\\\\tname = $name\\\\n+\\\\tcommonName =  $commonName\\\\n+\\\\torganizationName = $organizationName\\\\n+}\\\\n+$createResponse = $null\\\\n+try {\\\\n+    $createResponse = New-MgBetaNetworkAccessTlExternalCertificateAuthorityCertificate -BodyParameter $paramscsr -ErrorAction Stop\\\\n+} catch {\\\\n+    Write-Error \\\\\\\"Failed to create certificate signing request: $($_.Exception.Message)\\\\\\\"\\\\n+    exit 1\\\\n+}\\\\n+\\\\n+# Save CSR to file\\\\n+$csr = $createResponse.CertificateSigningRequest\\\\n+$CsrPath = \\\\\\\"$name.csr\\\\\\\"\\\\n+Set-Content -Path $CsrPath -Value $csr -Encoding ascii\\\\n+Write-Host \\\\\\\"CSR saved to $CsrPath\\\\\\\"\\\\n+\\\\n+# The unique identifier of the created certificate, used for uploading the signed certificate and chain\\\\n+$certId = $createResponse.Id\\\\n+\\\\n+# Certificate and chain file names\\\\n+$signedCert = \\\\\\\"TlsDemoCert.pem\\\\\\\"\\\\n+$chainContent = \\\\\\\"TlsDemoCertChain.pem\\\\\\\"\\\\n+\\\\n+# Submit CSR to ADCS to sign, using subordinate CA template, retrieve Request ID\\\\n+$submitOutput = certreq -submit -attrib \\\\\\\"CertificateTemplate:$Template\\\\\\\" -config $CAConfig $CsrPath $signedCert\\\\n+if (-not (Test-Path $signedCert)) {\\\\n+    Write-Error \\\\\\\"Certificate was not issued. Check CA or template permissions.\\\\\\\"\\\\n+    exit 1\\\\n+}\\\\n+Write-Host \\\\\\\"Certificate issued and saved to $signedCert\\\\\\\"\\\\n+\\\\n+# Extract Request ID from output\\\\n+$requestId = ($submitOutput | Select-String -Pattern 'RequestId:\\\\\\\\s*(\\\\\\\\d+)' | ForEach-Object { \\\\n+    if ($_.Matches.Count -gt 0) { $_.Matches[0].Groups[1].Value }\\\\n+})\\\\n+if (-not $requestId) {\\\\n+    Write-Error \\\\\\\"Could not determine Request ID from certreq output.\\\\\\\"\\\\n+    exit 1\\\\n+}\\\\n+Write-Host \\\\\\\"Request ID: $requestId\\\\\\\"\\\\n+\\\\n+# Retrieve certificate in pem and chain in p7b format\\\\n+$tempP7B =\\\\\\\"tempchain.p7b\\\\\\\"\\\\n+$tempPem =\\\\\\\"tempcert.pem\\\\\\\"\\\\n+Write-Host \\\\\\\"Retrieving full certificate chain...\\\\\\\"\\\\n+certreq -retrieve -config $CAConfig $requestId $tempPem $tempP7B \\\\n+if (-not (Test-Path $tempP7B )) {\\\\n+    Write-Error \\\\\\\"Failed to retrieve certificate chain.\\\\\\\"\\\\n+    exit 1\\\\n+}\\\\n+# Read the .p7b file as bytes\\\\n+$p7bBytes = [System.IO.File]::ReadAllBytes($tempP7B)\\\\n+# Create a certificate collection and import the .p7b content\\\\n+$certCollection = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2Collection\\\\n+$certCollection.Import($p7bBytes)\\\\n+# Sort certificates from intermediate to root (based on Issuer/Subject)\\\\n+# Initialize PEM block array\\\\n+$pemBlocks = @()\\\\n+# Loop through each certificate and convert to PEM format\\\\n+foreach ($cert in $certCollection) {\\\\n+    $base64 = [System.Convert]::ToBase64String($cert.RawData, 'InsertLineBreaks')\\\\n+    $pem = \\\\\\\"-----BEGIN CERTIFICATE-----`n$base64`n-----END CERTIFICATE-----\\\\\\\"\\\\n+    $pemBlocks += $pem\\\\n+}\\\\n+# Save all PEM blocks to a single file\\\\n+$pemBlocks -join \\\\\\\"`n\\\\\\\" | Set-Content -Path $chainContent -Encoding ascii\\\\n+Write-Host \\\\\\\"Certificate chain saved to $chainContent\\\\\\\"\\\\n+\\\\n+# Read certificate and chain\\\\n+if (-not (Test-Path $tempPem) -or ((Get-Content -Path $tempPem -Raw).Trim().Length -eq 0)) {\\\\n+    Write-Error \\\\\\\"The certificate file $tempPem does not exist or is empty. Aborting upload.\\\\\\\"\\\\n+    exit 1\\\\n+}\\\\n+$paramsupload = @{\\\\n+certificate = Get-Content -Path $tempPem -Raw\\\\n+chain       = Get-Content -Path $chainContent -Raw\\\\n+}\\\\n+# Upload the signed certificate and its chain to Microsoft Graph using the SDK cmdlet.\\\\n+# -ExternalCertificateAuthorityCertificateId: The unique ID of the certificate request previously created.\\\\n+# -BodyParameter: A hashtable containing the PEM-encoded certificate and chain as required by the API.\\\\n+#   }\\\\n+\\\\n+try {\\\\n+    Update-MgBetaNetworkAccessTlExternalCertificateAuthorityCertificate -ExternalCertificateAuthorityCertificateId $certId -BodyParameter $paramsupload\\\\n+} catch {\\\\n+    Write-Error \\\\\\\"Failed to upload certificate and chain: $($_.Exception.Message)\\\\\\\"\\\\n+    exit 1\\\\n+}\\\\n+Write-Host \\\\\\\"Your TLS certificate is created and uploaded successfully.\\\\\\\"\\\\n+\\\\n+# Delete temp files other than the signed certificate and chain.\\\\n+Remove-Item $CsrPath, $tempP7B, $tempPem -ErrorAction SilentlyContinue\\\\n+```\\\\n+\\\\n+## Related content\\\\n+- [Configure Transport Layer Security inspection](../how-to-transport-layer-security.md)\\\\n+- [Use PowerShell to generate and sign TLS certificates using OpenSSL](powershell-open-secure-sockets-layer.md)\\\"\\r\\n  },\\r\\n  {\\r\\n    \\\"sha\\\": \\\"c9701018dc1d1e3003baac2c63bed764f959c462\\\",\\r\\n    \\\"filename\\\": \\\"docs/global-secure-access/scripts/powershell-open-secure-sockets-layer.md\\\",\\r\\n    \\\"status\\\": \\\"added\\\",\\r\\n    \\\"additions\\\": 168,\\r\\n    \\\"deletions\\\": 0,\\r\\n    \\\"changes\\\": 168,\\r\\n    \\\"blob_url\\\": \\\"https://github.com/MicrosoftDocs/entra-docs/blob/17582c44d4741a58cfe6385db37c5920768a6d3e/docs%2Fglobal-secure-access%2Fscripts%2Fpowershell-open-secure-sockets-layer.md\\\",\\r\\n    \\\"raw_url\\\": \\\"https://github.com/MicrosoftDocs/entra-docs/raw/17582c44d4741a58cfe6385db37c5920768a6d3e/docs%2Fglobal-secure-access%2Fscripts%2Fpowershell-open-secure-sockets-layer.md\\\",\\r\\n    \\\"contents_url\\\": \\\"https://api.github.com/repos/MicrosoftDocs/entra-docs/contents/docs%2Fglobal-secure-access%2Fscripts%2Fpowershell-open-secure-sockets-layer.md?ref=17582c44d4741a58cfe6385db37c5920768a6d3e\\\",\\r\\n    \\\"patch\\\": \\\"@@ -0,0 +1,168 @@\\\\n+---\\\\n+title: PowerShell Sample - Create a TLS Certificate Using OpenSSL\\\\n+description: Use this PowerShell script to generate and sign Transport Layer Security (TLS) certificates using OpenSSL in a test environment.\\\\n+author: HULKsmashGithub\\\\n+ms.author: jayrusso\\\\n+manager: dougeby\\\\n+ms.service: global-secure-access\\\\n+ms.topic: sample\\\\n+ms.date: 09/09/2025\\\\n+ms.reviewer: teresayao\\\\n+\\\\n+#customer intent: As an admin, I want to automate the creation of TLS certificates using PowerShell so that I can streamline my testing process.\\\\n+\\\\n+---\\\\n+\\\\n+# Use PowerShell to create and sign TLS certificates using OpenSSL\\\\n+\\\\n+This script automates generating and signing Transport Layer Security (TLS) certificates using OpenSSL. It creates a certificate signing request (CSR) using the TLS inspection graph API. The script creates a self-signed root certificate authority using OpenSSL, signs the CSR, and uploads the certificate and chain to TLS inspection settings.\\\\n+\\\\n+## Prerequisites\\\\n+- Install OpenSSL for Windows or Linux.\\\\n+\\\\n+> [!NOTE]\\\\n+> While other tools might be available for certificate management, this sample code in this article uses OpenSSL. OpenSSL is bundled with many Linux distributions, such as Ubuntu.\\\\n+\\\\n+## Generate and sign TLS certificates\\\\n+\\\\n+```powershell\\\\n+# This script requires the following:\\\\n+#    - PowerShell 5.1 (x64) or later\\\\n+#    - Module: Microsoft.Graph.Beta\\\\n+#\\\\n+# Before you begin:\\\\n+#    \\\\n+# - Make sure you're running PowerShell as an administrator\\\\n+# - Make sure you run: Install-Module Microsoft.Graph.Beta -AllowClobber -Force\\\\n+# Ensure Microsoft.Graph.Beta module is available\\\\n+\\\\n+# Import Module\\\\n+\\\\n+Import-Module Microsoft.Graph.Beta.NetworkAccess\\\\n+\\\\n+# Connect to Microsoft Graph (handles token for you)\\\\n+Connect-MgGraph -Scopes \\\\\\\"NetworkAccess.ReadWrite.All\\\\\\\" -NoWelcome\\\\n+\\\\n+# Modify the following with your own settings before running the script:\\\\n+# Parameters of the certificate sign request (letters and numbers only and within 12 characters).\\\\n+    $name = \\\\\\\"TLSiDemoCA\\\\\\\"\\\\n+    $commonName = \\\\\\\"Contoso TLS Demo\\\\\\\"\\\\n+    $organizationName = \\\\\\\"Contoso\\\\\\\"\\\\n+\\\\n+# Replace with your openSSLpath\\\\n+    $openSSLPath = \\\\\\\"C:\\\\\\\\Program Files\\\\\\\\OpenSSL-Win64\\\\\\\\bin\\\\\\\\openssl.exe\\\\\\\"\\\\n+\\\\n+# Self-signed CA file names\\\\n+$rootKey = \\\\\\\"TlsDemorootCA.key\\\\\\\"\\\\n+$rootCert = \\\\\\\"TlsDemorootCAcert.pem\\\\\\\"\\\\n+$subject = \\\\\\\"/C=US/ST=Washington/L=Redmond/O=Contoso/CN=Contoso\\\\\\\"\\\\n+$signedCert = \\\\\\\"signedcertificate.pem\\\\\\\"\\\\n+\\\\n+#: Check if External Certificate Authority Certificates already exists\\\\n+try {\\\\n+    $response = Get-MgBetaNetworkAccessTlExternalCertificateAuthorityCertificate\\\\n+    if ($response.Count -gt 0) {\\\\n+        Write-Host \\\\\\\"A certificate for TLS inspection already exists.\\\\\\\"\\\\n+\\\\texit 1\\\\n+    } \\\\n+}\\\\n+catch {\\\\n+    Write-Error \\\\\\\"The Graph SDK call failed: $($_.Exception.Message)\\\\\\\"\\\\n+}\\\\n+\\\\n+# Create the certificate signing request (CSR)\\\\n+\\\\n+$paramscsr = @{\\\\n+\\\\t\\\\\\\"@odata.type\\\\\\\" = \\\\\\\"#microsoft.graph.networkaccess.externalCertificateAuthorityCertificate\\\\\\\"\\\\n+\\\\tname = $name\\\\n+\\\\tcommonName =  $commonName\\\\n+\\\\torganizationName = $organizationName\\\\n+}\\\\n+$createResponse = $null\\\\n+try {\\\\n+  $createResponse = New-MgBetaNetworkAccessTlExternalCertificateAuthorityCertificate -BodyParameter $paramscsr -ErrorAction Stop\\\\n+} \\\\n+catch {\\\\n+    Write-Error \\\\\\\"Failed to create certificate signing request: $($_.Exception.Message)\\\\\\\"\\\\n+    Exit 1\\\\t\\\\n+}\\\\n+# Save CSR to file\\\\n+$csr = $createResponse.CertificateSigningRequest\\\\n+$csrPath = \\\\\\\"$name.csr\\\\\\\"\\\\n+Set-Content -Path $csrPath -Value $csr\\\\n+Write-Host \\\\\\\"CSR saved to $csrPath\\\\\\\"\\\\n+\\\\n+# Save the certificate ID to upload later:\\\\n+$externalCertificateAuthorityCertificateId = $createResponse.Id\\\\n+\\\\n+# Create openssl.cnf with predefined profiles\\\\n+$opensslCnfContent = @\\\\\\\"\\\\n+[ rootCA_ext ]\\\\n+subjectKeyIdentifier = hash\\\\n+authorityKeyIdentifier = keyid:always,issuer\\\\n+basicConstraints = critical, CA:true\\\\n+keyUsage = critical, digitalSignature, cRLSign, keyCertSign\\\\n+\\\\n+[ interCA_ext ]\\\\n+subjectKeyIdentifier = hash\\\\n+authorityKeyIdentifier = keyid:always,issuer\\\\n+basicConstraints = critical, CA:true, pathlen:1\\\\n+keyUsage = critical, digitalSignature, cRLSign, keyCertSign\\\\n+\\\\n+[ signedCA_ext ]\\\\n+basicConstraints = critical, CA:true\\\\n+keyUsage = critical, digitalSignature, cRLSign, keyCertSign\\\\n+extendedKeyUsage = serverAuth\\\\n+\\\\n+[ server_ext ]\\\\n+subjectKeyIdentifier = hash\\\\n+authorityKeyIdentifier = keyid:always,issuer\\\\n+basicConstraints = critical, CA:false\\\\n+keyUsage = critical, digitalSignature\\\\n+extendedKeyUsage = serverAuth\\\\n+\\\\\\\"@\\\\n+\\\\n+$opensslCnfPath = \\\\\\\"openssl.cnf\\\\\\\"\\\\n+\\\\n+# Write content to openssl.cnf file\\\\n+Set-Content -Path $opensslCnfPath -Value $opensslCnfContent -Encoding ASCII\\\\n+\\\\n+\\\\n+\\\\n+# Generate Root CA private key and certificate. Note: You need to install the Root CA certificate in the trusted certificate store of testing users' devices.\\\\n+Write-Host \\\\\\\"Generating Root CA key and certificate...\\\\\\\"\\\\n+& $openSSLPath req -x509 -new -nodes -newkey rsa:4096 -keyout $rootKey -sha256 -days 370 -out $rootCert -subj $subject -config $opensslCnfPath -extensions rootCA_ext\\\\n+\\\\n+# Sign CSR using Root CA\\\\n+if (Test-Path $csrPath) {\\\\n+    Write-Host \\\\\\\"Signing CSR file $csrPath...\\\\\\\"\\\\n+    & $openSSLPath x509 -req -in $csrPath -CA $rootCert -CAkey $rootKey -CAcreateserial -out $signedCert -days 370 -sha256 -extfile $opensslCnfPath -extensions signedCA_ext\\\\n+    Write-Host \\\\\\\"Signed certificate saved to $signedCert\\\\\\\"\\\\n+} else {\\\\n+    Write-Host \\\\\\\"CSR file '$csrPath' not found. Please generate it first.\\\\\\\"\\\\n+}\\\\n+\\\\n+# Read certificate and chain\\\\n+$paramsupload = @{\\\\n+certificate = Get-Content -Path $SignedCert -Raw\\\\n+chain       = Get-Content -Path $RootCert -Raw\\\\n+}\\\\n+# Upload using SDK cmdlet\\\\n+Update-MgBetaNetworkAccessTlExternalCertificateAuthorityCertificate -ExternalCertificateAuthorityCertificateId $externalCertificateAuthorityCertificateId -BodyParameter $paramsupload\\\\n+\\\\n+# Upload the signed certificate and its chain to Microsoft Graph using the SDK cmdlet.\\\\n+# -ExternalCertificateAuthorityCertificateId: The unique ID of the certificate request previously created.\\\\n+# -BodyParameter: A hashtable containing the PEM-encoded certificate and chain as required by the API.\\\\n+\\\\n+try {Update-MgBetaNetworkAccessTlExternalCertificateAuthorityCertificate -ExternalCertificateAuthorityCertificateId $externalCertificateAuthorityCertificateId -BodyParameter $paramsupload\\\\n+-ErrorAction Stop} catch {\\\\n+Write-Error \\\\\\\"Failed to upload certificate and chain: $($_.Exception.Message)\\\\\\\"\\\\n+exit 1\\\\n+}\\\\n+\\\\n+Write-Host \\\\\\\"Upload complete via Microsoft Graph SDK.\\\\\\\"\\\\n+```\\\\n+\\\\n+## Related content\\\\n+- [Configure Transport Layer Security inspection](../how-to-transport-layer-security.md)\\\\n+- [Use PowerShell to generate and sign TLS certificates using Active Directory Certificate Services](powershell-active-directory-certificate-service.md)\\\"\\r\\n  },\\r\\n  {\\r\\n    \\\"sha\\\": \\\"3d803dd39ad2ffa7c1213102be44cab2d5e94bc0\\\",\\r\\n    \\\"filename\\\": \\\"docs/global-secure-access/toc.yml\\\",\\r\\n    \\\"status\\\": \\\"modified\\\",\\r\\n    \\\"additions\\\": 4,\\r\\n    \\\"deletions\\\": 0,\\r\\n    \\\"changes\\\": 4,\\r\\n    \\\"blob_url\\\": \\\"https://github.com/MicrosoftDocs/entra-docs/blob/17582c44d4741a58cfe6385db37c5920768a6d3e/docs%2Fglobal-secure-access%2Ftoc.yml\\\",\\r\\n    \\\"raw_url\\\": \\\"https://github.com/MicrosoftDocs/entra-docs/raw/17582c44d4741a58cfe6385db37c5920768a6d3e/docs%2Fglobal-secure-access%2Ftoc.yml\\\",\\r\\n    \\\"contents_url\\\": \\\"https://api.github.com/repos/MicrosoftDocs/entra-docs/contents/docs%2Fglobal-secure-access%2Ftoc.yml?ref=17582c44d4741a58cfe6385db37c5920768a6d3e\\\",\\r\\n    \\\"patch\\\": \\\"@@ -38,6 +38,10 @@ items:\\\\n     href: ./scripts/powershell-bypass-script.md\\\\n   - name: Bypass Intune endpoints from the Internet Access profile\\\\n     href: ./scripts/powershell-add-internet-access-device-compliance-bypasses.md\\\\n+  - name: Create a TLS certificate using ADCS\\\\n+    href: ./scripts/powershell-active-directory-certificate-service.md\\\\n+  - name: Create a TLS certificate using OpenSSL\\\\n+    href: ./scripts/powershell-open-secure-sockets-layer.md\\\\n - name: Concepts\\\\n   expanded: true\\\\n   items: \\\"\\r\\n  },\\r\\n  {\\r\\n    \\\"sha\\\": \\\"fced243e505f0e63955405ed884f507082c5d67f\\\",\\r\\n    \\\"filename\\\": \\\"docs/identity-platform/reply-url.md\\\",\\r\\n    \\\"status\\\": \\\"modified\\\",\\r\\n    \\\"additions\\\": 7,\\r\\n    \\\"deletions\\\": 2,\\r\\n    \\\"changes\\\": 9,\\r\\n    \\\"blob_url\\\": \\\"https://github.com/MicrosoftDocs/entra-docs/blob/17582c44d4741a58cfe6385db37c5920768a6d3e/docs%2Fidentity-platform%2Freply-url.md\\\",\\r\\n    \\\"raw_url\\\": \\\"https://github.com/MicrosoftDocs/entra-docs/raw/17582c44d4741a58cfe6385db37c5920768a6d3e/docs%2Fidentity-platform%2Freply-url.md\\\",\\r\\n    \\\"contents_url\\\": \\\"https://api.github.com/repos/MicrosoftDocs/entra-docs/contents/docs%2Fidentity-platform%2Freply-url.md?ref=17582c44d4741a58cfe6385db37c5920768a6d3e\\\",\\r\\n    \\\"patch\\\": \\\"@@ -160,18 +160,23 @@ Per [RFC 8252 sections 8.3](https://tools.ietf.org/html/rfc8252#section-8.3) and\\\\n 1. `http` URI schemes are acceptable because the redirect never leaves the device. As such, both of these URIs are acceptable:\\\\n     - `http://localhost/myApp`\\\\n     - `https://localhost/myApp`\\\\n-1. Due to ephemeral port ranges often required by native applications, the port component (for example, `:5001` or `:443`) is ignored for the purposes of matching a redirect URI. As a result, all of these URIs are considered equivalent:\\\\n+\\\\n+1. Due to ephemeral port ranges often required by native applications, the port component (for example, `:5001` or `:443`) is ignored for the purposes of matching a localhost redirect URI. As a result, all of these URIs are considered equivalent:\\\\n     - `http://localhost/MyApp`\\\\n     - `http://localhost:1234/MyApp`\\\\n     - `http://localhost:5000/MyApp`\\\\n     - `http://localhost:8080/MyApp`\\\\n \\\\n+    This is *only* true for localhost redirect URIs. In all other cases, the port component is *not* ignored when matching redirect URIs. \\\\n+\\\\n From a development standpoint, this means a few things:\\\\n \\\\n-* Do not register multiple redirect URIs where only the port differs. The login server picks one arbitrarily and uses the behavior associated with that redirect URI (for example, whether it's a `web`-, `native`-, or `spa`-type redirect).\\\\n+* Do not register multiple localhost redirect URIs where only the port differs. The login server picks one arbitrarily and uses the behavior associated with that registered redirect URI (for example, whether it's a `web`-, `native`-, or `spa`-type redirect).\\\\n \\\\n     This is especially important when you want to use different authentication flows in the same application registration, for example both the authorization code grant and implicit flow. To associate the correct response behavior with each redirect URI, the login server must be able to distinguish between the redirect URIs and can't do so when only the port differs.\\\\n+\\\\n * To register multiple redirect URIs on localhost to test different flows during development, differentiate them using the *path* component of the URI. For example, `http://localhost/MyWebApp` doesn't match `http://localhost/MyNativeApp`.\\\\n+\\\\n * The IPv6 loopback address (`[::1]`) isn't currently supported.\\\\n \\\\n #### Prefer 127.0.0.1 over localhost\\\"\\r\\n  }\\r\\n]. Please summarise it in a few sentences, using UK grammar and ensure the response is formatted for markdown. Do not start the response with here is summary.\"}",
    "Response": "This commit introduces two new PowerShell scripts to the Microsoft Entra documentation for Global Secure Access. These scripts demonstrate how to automate the creation and signing of Transport Layer Security (TLS) certificates for testing purposes, one using Active Directory Certificate Services (ADCS) and the other using OpenSSL. Additionally, the table of contents for Global Secure Access has been updated to include links to these new scripts, and a clarification has been made to the documentation regarding the matching of redirect URIs in the identity platform section, specifically addressing the handling of port numbers for localhost URIs.",
    "Model": "google:gemini-2.5-flash-lite",
    "Provider": "google",
    "ModelName": "gemini-2.5-flash-lite",
    "Timestamp": "2025-09-09T23:01:09.5006134+00:00"
  },
  "files": [
    {
      "filename": "docs/global-secure-access/scripts/powershell-active-directory-certificate-service.md",
      "status": "added",
      "additions": 168,
      "deletions": 0
    },
    {
      "filename": "docs/global-secure-access/scripts/powershell-open-secure-sockets-layer.md",
      "status": "added",
      "additions": 168,
      "deletions": 0
    },
    {
      "filename": "docs/global-secure-access/toc.yml",
      "status": "modified",
      "additions": 4,
      "deletions": 0
    },
    {
      "filename": "docs/identity-platform/reply-url.md",
      "status": "modified",
      "additions": 7,
      "deletions": 2
    }
  ]
}